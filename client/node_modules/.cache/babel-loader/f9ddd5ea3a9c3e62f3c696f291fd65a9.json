{"ast":null,"code":"\"use strict\";\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar React = __importStar(require(\"react\"));\nvar KEYCODE_Y = 89;\nvar KEYCODE_Z = 90;\nvar KEYCODE_M = 77;\nvar KEYCODE_PARENS = 57;\nvar KEYCODE_BRACKETS = 219;\nvar KEYCODE_QUOTE = 222;\nvar KEYCODE_BACK_QUOTE = 192;\nvar HISTORY_LIMIT = 100;\nvar HISTORY_TIME_GAP = 3000;\nvar isWindows = typeof window !== 'undefined' && 'navigator' in window && /Win/i.test(navigator.platform);\nvar isMacLike = typeof window !== 'undefined' && 'navigator' in window && /(Mac|iPhone|iPod|iPad)/i.test(navigator.platform);\nvar className = 'npm__react-simple-code-editor__textarea';\nvar cssText = /* CSS */\"\\n/**\\n * Reset the text fill color so that placeholder is visible\\n */\\n.\".concat(className, \":empty {\\n  -webkit-text-fill-color: inherit !important;\\n}\\n\\n/**\\n * Hack to apply on some CSS on IE10 and IE11\\n */\\n@media all and (-ms-high-contrast: none), (-ms-high-contrast: active) {\\n  /**\\n    * IE doesn't support '-webkit-text-fill-color'\\n    * So we use 'color: transparent' to make the text transparent on IE\\n    * Unlike other browsers, it doesn't affect caret color in IE\\n    */\\n  .\").concat(className, \" {\\n    color: transparent !important;\\n  }\\n\\n  .\").concat(className, \"::selection {\\n    background-color: #accef7 !important;\\n    color: transparent !important;\\n  }\\n}\\n\");\nvar Editor = React.forwardRef(function Editor(props, ref) {\n  var autoFocus = props.autoFocus,\n    disabled = props.disabled,\n    form = props.form,\n    highlight = props.highlight,\n    _a = props.ignoreTabKey,\n    ignoreTabKey = _a === void 0 ? false : _a,\n    _b = props.insertSpaces,\n    insertSpaces = _b === void 0 ? true : _b,\n    maxLength = props.maxLength,\n    minLength = props.minLength,\n    name = props.name,\n    onBlur = props.onBlur,\n    onClick = props.onClick,\n    onFocus = props.onFocus,\n    onKeyDown = props.onKeyDown,\n    onKeyUp = props.onKeyUp,\n    onValueChange = props.onValueChange,\n    _c = props.padding,\n    padding = _c === void 0 ? 0 : _c,\n    placeholder = props.placeholder,\n    preClassName = props.preClassName,\n    readOnly = props.readOnly,\n    required = props.required,\n    style = props.style,\n    _d = props.tabSize,\n    tabSize = _d === void 0 ? 2 : _d,\n    textareaClassName = props.textareaClassName,\n    textareaId = props.textareaId,\n    value = props.value,\n    rest = __rest(props, [\"autoFocus\", \"disabled\", \"form\", \"highlight\", \"ignoreTabKey\", \"insertSpaces\", \"maxLength\", \"minLength\", \"name\", \"onBlur\", \"onClick\", \"onFocus\", \"onKeyDown\", \"onKeyUp\", \"onValueChange\", \"padding\", \"placeholder\", \"preClassName\", \"readOnly\", \"required\", \"style\", \"tabSize\", \"textareaClassName\", \"textareaId\", \"value\"]);\n  var historyRef = React.useRef({\n    stack: [],\n    offset: -1\n  });\n  var inputRef = React.useRef(null);\n  var _e = React.useState(true),\n    capture = _e[0],\n    setCapture = _e[1];\n  var contentStyle = {\n    paddingTop: typeof padding === 'object' ? padding.top : padding,\n    paddingRight: typeof padding === 'object' ? padding.right : padding,\n    paddingBottom: typeof padding === 'object' ? padding.bottom : padding,\n    paddingLeft: typeof padding === 'object' ? padding.left : padding\n  };\n  var highlighted = highlight(value);\n  var getLines = function (text, position) {\n    return text.substring(0, position).split('\\n');\n  };\n  var recordChange = React.useCallback(function (record, overwrite) {\n    var _a, _b, _c;\n    if (overwrite === void 0) {\n      overwrite = false;\n    }\n    var _d = historyRef.current,\n      stack = _d.stack,\n      offset = _d.offset;\n    if (stack.length && offset > -1) {\n      // When something updates, drop the redo operations\n      historyRef.current.stack = stack.slice(0, offset + 1);\n      // Limit the number of operations to 100\n      var count = historyRef.current.stack.length;\n      if (count > HISTORY_LIMIT) {\n        var extras = count - HISTORY_LIMIT;\n        historyRef.current.stack = stack.slice(extras, count);\n        historyRef.current.offset = Math.max(historyRef.current.offset - extras, 0);\n      }\n    }\n    var timestamp = Date.now();\n    if (overwrite) {\n      var last = historyRef.current.stack[historyRef.current.offset];\n      if (last && timestamp - last.timestamp < HISTORY_TIME_GAP) {\n        // A previous entry exists and was in short interval\n        // Match the last word in the line\n        var re = /[^a-z0-9]([a-z0-9]+)$/i;\n        // Get the previous line\n        var previous = (_a = getLines(last.value, last.selectionStart).pop()) === null || _a === void 0 ? void 0 : _a.match(re);\n        // Get the current line\n        var current = (_b = getLines(record.value, record.selectionStart).pop()) === null || _b === void 0 ? void 0 : _b.match(re);\n        if ((previous === null || previous === void 0 ? void 0 : previous[1]) && ((_c = current === null || current === void 0 ? void 0 : current[1]) === null || _c === void 0 ? void 0 : _c.startsWith(previous[1]))) {\n          // The last word of the previous line and current line match\n          // Overwrite previous entry so that undo will remove whole word\n          historyRef.current.stack[historyRef.current.offset] = __assign(__assign({}, record), {\n            timestamp: timestamp\n          });\n          return;\n        }\n      }\n    }\n    // Add the new operation to the stack\n    historyRef.current.stack.push(__assign(__assign({}, record), {\n      timestamp: timestamp\n    }));\n    historyRef.current.offset++;\n  }, []);\n  var recordCurrentState = React.useCallback(function () {\n    var input = inputRef.current;\n    if (!input) return;\n    // Save current state of the input\n    var value = input.value,\n      selectionStart = input.selectionStart,\n      selectionEnd = input.selectionEnd;\n    recordChange({\n      value: value,\n      selectionStart: selectionStart,\n      selectionEnd: selectionEnd\n    });\n  }, [recordChange]);\n  var updateInput = function (record) {\n    var input = inputRef.current;\n    if (!input) return;\n    // Update values and selection state\n    input.value = record.value;\n    input.selectionStart = record.selectionStart;\n    input.selectionEnd = record.selectionEnd;\n    onValueChange === null || onValueChange === void 0 ? void 0 : onValueChange(record.value);\n  };\n  var applyEdits = function (record) {\n    // Save last selection state\n    var input = inputRef.current;\n    var last = historyRef.current.stack[historyRef.current.offset];\n    if (last && input) {\n      historyRef.current.stack[historyRef.current.offset] = __assign(__assign({}, last), {\n        selectionStart: input.selectionStart,\n        selectionEnd: input.selectionEnd\n      });\n    }\n    // Save the changes\n    recordChange(record);\n    updateInput(record);\n  };\n  var undoEdit = function () {\n    var _a = historyRef.current,\n      stack = _a.stack,\n      offset = _a.offset;\n    // Get the previous edit\n    var record = stack[offset - 1];\n    if (record) {\n      // Apply the changes and update the offset\n      updateInput(record);\n      historyRef.current.offset = Math.max(offset - 1, 0);\n    }\n  };\n  var redoEdit = function () {\n    var _a = historyRef.current,\n      stack = _a.stack,\n      offset = _a.offset;\n    // Get the next edit\n    var record = stack[offset + 1];\n    if (record) {\n      // Apply the changes and update the offset\n      updateInput(record);\n      historyRef.current.offset = Math.min(offset + 1, stack.length - 1);\n    }\n  };\n  var handleKeyDown = function (e) {\n    if (onKeyDown) {\n      onKeyDown(e);\n      if (e.defaultPrevented) {\n        return;\n      }\n    }\n    if (e.key === 'Escape') {\n      e.currentTarget.blur();\n    }\n    var _a = e.currentTarget,\n      value = _a.value,\n      selectionStart = _a.selectionStart,\n      selectionEnd = _a.selectionEnd;\n    var tabCharacter = (insertSpaces ? ' ' : '\\t').repeat(tabSize);\n    if (e.key === 'Tab' && !ignoreTabKey && capture) {\n      // Prevent focus change\n      e.preventDefault();\n      if (e.shiftKey) {\n        // Unindent selected lines\n        var linesBeforeCaret = getLines(value, selectionStart);\n        var startLine_1 = linesBeforeCaret.length - 1;\n        var endLine_1 = getLines(value, selectionEnd).length - 1;\n        var nextValue = value.split('\\n').map(function (line, i) {\n          if (i >= startLine_1 && i <= endLine_1 && line.startsWith(tabCharacter)) {\n            return line.substring(tabCharacter.length);\n          }\n          return line;\n        }).join('\\n');\n        if (value !== nextValue) {\n          var startLineText = linesBeforeCaret[startLine_1];\n          applyEdits({\n            value: nextValue,\n            // Move the start cursor if first line in selection was modified\n            // It was modified only if it started with a tab\n            selectionStart: (startLineText === null || startLineText === void 0 ? void 0 : startLineText.startsWith(tabCharacter)) ? selectionStart - tabCharacter.length : selectionStart,\n            // Move the end cursor by total number of characters removed\n            selectionEnd: selectionEnd - (value.length - nextValue.length)\n          });\n        }\n      } else if (selectionStart !== selectionEnd) {\n        // Indent selected lines\n        var linesBeforeCaret = getLines(value, selectionStart);\n        var startLine_2 = linesBeforeCaret.length - 1;\n        var endLine_2 = getLines(value, selectionEnd).length - 1;\n        var startLineText = linesBeforeCaret[startLine_2];\n        applyEdits({\n          value: value.split('\\n').map(function (line, i) {\n            if (i >= startLine_2 && i <= endLine_2) {\n              return tabCharacter + line;\n            }\n            return line;\n          }).join('\\n'),\n          // Move the start cursor by number of characters added in first line of selection\n          // Don't move it if it there was no text before cursor\n          selectionStart: startLineText && /\\S/.test(startLineText) ? selectionStart + tabCharacter.length : selectionStart,\n          // Move the end cursor by total number of characters added\n          selectionEnd: selectionEnd + tabCharacter.length * (endLine_2 - startLine_2 + 1)\n        });\n      } else {\n        var updatedSelection = selectionStart + tabCharacter.length;\n        applyEdits({\n          // Insert tab character at caret\n          value: value.substring(0, selectionStart) + tabCharacter + value.substring(selectionEnd),\n          // Update caret position\n          selectionStart: updatedSelection,\n          selectionEnd: updatedSelection\n        });\n      }\n    } else if (e.key === 'Backspace') {\n      var hasSelection = selectionStart !== selectionEnd;\n      var textBeforeCaret = value.substring(0, selectionStart);\n      if (textBeforeCaret.endsWith(tabCharacter) && !hasSelection) {\n        // Prevent default delete behaviour\n        e.preventDefault();\n        var updatedSelection = selectionStart - tabCharacter.length;\n        applyEdits({\n          // Remove tab character at caret\n          value: value.substring(0, selectionStart - tabCharacter.length) + value.substring(selectionEnd),\n          // Update caret position\n          selectionStart: updatedSelection,\n          selectionEnd: updatedSelection\n        });\n      }\n    } else if (e.key === 'Enter') {\n      // Ignore selections\n      if (selectionStart === selectionEnd) {\n        // Get the current line\n        var line = getLines(value, selectionStart).pop();\n        var matches = line === null || line === void 0 ? void 0 : line.match(/^\\s+/);\n        if (matches === null || matches === void 0 ? void 0 : matches[0]) {\n          e.preventDefault();\n          // Preserve indentation on inserting a new line\n          var indent = '\\n' + matches[0];\n          var updatedSelection = selectionStart + indent.length;\n          applyEdits({\n            // Insert indentation character at caret\n            value: value.substring(0, selectionStart) + indent + value.substring(selectionEnd),\n            // Update caret position\n            selectionStart: updatedSelection,\n            selectionEnd: updatedSelection\n          });\n        }\n      }\n    } else if (e.keyCode === KEYCODE_PARENS || e.keyCode === KEYCODE_BRACKETS || e.keyCode === KEYCODE_QUOTE || e.keyCode === KEYCODE_BACK_QUOTE) {\n      var chars = void 0;\n      if (e.keyCode === KEYCODE_PARENS && e.shiftKey) {\n        chars = ['(', ')'];\n      } else if (e.keyCode === KEYCODE_BRACKETS) {\n        if (e.shiftKey) {\n          chars = ['{', '}'];\n        } else {\n          chars = ['[', ']'];\n        }\n      } else if (e.keyCode === KEYCODE_QUOTE) {\n        if (e.shiftKey) {\n          chars = ['\"', '\"'];\n        } else {\n          chars = [\"'\", \"'\"];\n        }\n      } else if (e.keyCode === KEYCODE_BACK_QUOTE && !e.shiftKey) {\n        chars = ['`', '`'];\n      }\n      // If text is selected, wrap them in the characters\n      if (selectionStart !== selectionEnd && chars) {\n        e.preventDefault();\n        applyEdits({\n          value: value.substring(0, selectionStart) + chars[0] + value.substring(selectionStart, selectionEnd) + chars[1] + value.substring(selectionEnd),\n          // Update caret position\n          selectionStart: selectionStart,\n          selectionEnd: selectionEnd + 2\n        });\n      }\n    } else if ((isMacLike ?\n    // Trigger undo with ⌘+Z on Mac\n    e.metaKey && e.keyCode === KEYCODE_Z :\n    // Trigger undo with Ctrl+Z on other platforms\n    e.ctrlKey && e.keyCode === KEYCODE_Z) && !e.shiftKey && !e.altKey) {\n      e.preventDefault();\n      undoEdit();\n    } else if ((isMacLike ?\n    // Trigger redo with ⌘+Shift+Z on Mac\n    e.metaKey && e.keyCode === KEYCODE_Z && e.shiftKey : isWindows ?\n    // Trigger redo with Ctrl+Y on Windows\n    e.ctrlKey && e.keyCode === KEYCODE_Y :\n    // Trigger redo with Ctrl+Shift+Z on other platforms\n    e.ctrlKey && e.keyCode === KEYCODE_Z && e.shiftKey) && !e.altKey) {\n      e.preventDefault();\n      redoEdit();\n    } else if (e.keyCode === KEYCODE_M && e.ctrlKey && (isMacLike ? e.shiftKey : true)) {\n      e.preventDefault();\n      // Toggle capturing tab key so users can focus away\n      setCapture(function (prev) {\n        return !prev;\n      });\n    }\n  };\n  var handleChange = function (e) {\n    var _a = e.currentTarget,\n      value = _a.value,\n      selectionStart = _a.selectionStart,\n      selectionEnd = _a.selectionEnd;\n    recordChange({\n      value: value,\n      selectionStart: selectionStart,\n      selectionEnd: selectionEnd\n    }, true);\n    onValueChange(value);\n  };\n  React.useEffect(function () {\n    recordCurrentState();\n  }, [recordCurrentState]);\n  React.useImperativeHandle(ref, function () {\n    return {\n      get session() {\n        return {\n          history: historyRef.current\n        };\n      },\n      set session(session) {\n        historyRef.current = session.history;\n      }\n    };\n  }, []);\n  return React.createElement(\"div\", __assign({}, rest, {\n    style: __assign(__assign({}, styles.container), style)\n  }), React.createElement(\"pre\", __assign({\n    className: preClassName,\n    \"aria-hidden\": \"true\",\n    style: __assign(__assign(__assign({}, styles.editor), styles.highlight), contentStyle)\n  }, typeof highlighted === 'string' ? {\n    dangerouslySetInnerHTML: {\n      __html: highlighted + '<br />'\n    }\n  } : {\n    children: highlighted\n  })), React.createElement(\"textarea\", {\n    ref: function (c) {\n      return inputRef.current = c;\n    },\n    style: __assign(__assign(__assign({}, styles.editor), styles.textarea), contentStyle),\n    className: className + (textareaClassName ? \" \".concat(textareaClassName) : ''),\n    id: textareaId,\n    value: value,\n    onChange: handleChange,\n    onKeyDown: handleKeyDown,\n    onClick: onClick,\n    onKeyUp: onKeyUp,\n    onFocus: onFocus,\n    onBlur: onBlur,\n    disabled: disabled,\n    form: form,\n    maxLength: maxLength,\n    minLength: minLength,\n    name: name,\n    placeholder: placeholder,\n    readOnly: readOnly,\n    required: required,\n    autoFocus: autoFocus,\n    autoCapitalize: \"off\",\n    autoComplete: \"off\",\n    autoCorrect: \"off\",\n    spellCheck: false,\n    \"data-gramm\": false\n  }), React.createElement(\"style\", {\n    dangerouslySetInnerHTML: {\n      __html: cssText\n    }\n  }));\n});\nvar styles = {\n  container: {\n    position: 'relative',\n    textAlign: 'left',\n    boxSizing: 'border-box',\n    padding: 0,\n    overflow: 'hidden'\n  },\n  textarea: {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    height: '100%',\n    width: '100%',\n    resize: 'none',\n    color: 'inherit',\n    overflow: 'hidden',\n    MozOsxFontSmoothing: 'grayscale',\n    WebkitFontSmoothing: 'antialiased',\n    WebkitTextFillColor: 'transparent'\n  },\n  highlight: {\n    position: 'relative',\n    pointerEvents: 'none'\n  },\n  editor: {\n    margin: 0,\n    border: 0,\n    background: 'none',\n    boxSizing: 'inherit',\n    display: 'inherit',\n    fontFamily: 'inherit',\n    fontSize: 'inherit',\n    fontStyle: 'inherit',\n    fontVariantLigatures: 'inherit',\n    fontWeight: 'inherit',\n    letterSpacing: 'inherit',\n    lineHeight: 'inherit',\n    tabSize: 'inherit',\n    textIndent: 'inherit',\n    textRendering: 'inherit',\n    textTransform: 'inherit',\n    whiteSpace: 'pre-wrap',\n    wordBreak: 'keep-all',\n    overflowWrap: 'break-word'\n  }\n};\nexports.default = Editor;","map":null,"metadata":{},"sourceType":"script"}